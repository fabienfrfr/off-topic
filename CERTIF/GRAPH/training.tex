\documentclass{beamer}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{tikz}
\usetikzlibrary{positioning}

% Définition des couleurs utilisées dans TikZ

\definecolor{MediumPurple}{RGB}{147,112,219}
\definecolor{Chartreuse2}{RGB}{102,205,0}
\definecolor{Chartreuse4}{RGB}{69,139,0}

\usetheme{Madrid}
\usecolortheme{seahorse}

% Configuration des listings pour C#, SQL, Python
\lstset{
  language=[Sharp]C,
  basicstyle=\ttfamily\small,
  keywordstyle=\color{blue}\bfseries,
  commentstyle=\color{gray}\itshape,
  stringstyle=\color{red},
  numbers=left,
  numberstyle=\tiny,
  stepnumber=1,
  numbersep=5pt,
  showstringspaces=false,
  breaklines=true,
  frame=single,
  backgroundcolor=\color{gray!10}
}

\title{Knowledge Management System :\\Optimisation de la connaissance numérique}
\author{Fabien FURFARO}
\date{\today}

\begin{document}

\frame{\titlepage}

\begin{frame}
  \frametitle{Sommaire}
  \tableofcontents
\end{frame}

\section{Pourquoi a-t-on besoin de gestionnaire de connaissance ?}

\begin{frame}
  \frametitle{Évolution de la transmission du savoir}
  \begin{itemize}
    \item Transmission orale
    \item Invention de l’écriture
    \item Traduction et diffusion manuscrite
    \item Imprimerie
    \item Révolution industrielle : normalisation
    \item Numérisation : explosion des données, multiplication des supports et des silos
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Conséquences de la numérisation}
  \begin{itemize}
    \item Volume massif de données (“Big Data”)
    \item Systèmes hétérogènes, silos informationnels
    \item Problèmes : redondance, perte de contexte, difficulté à relier les informations
    \item Importance croissante de l’optimisation de la gestion des connaissances numériques
  \end{itemize}
\end{frame}

\section{Qu'est-ce qu'un Knowledge Management System (KMS) ?}

\begin{frame}
  \frametitle{Définitions et objectifs d’un KMS}
  \begin{itemize}
    \item Collecter, organiser, stocker, partager et exploiter les connaissances d’une organisation
    \item Repose sur outils logiciels, méthodes et culture de partage
    \item Objectifs :
      \begin{itemize}
        \item Décision rapide et fiabilisée
        \item Innovation & compétitivité
        \item Réduction de la perte d’expertise (turnover)
        \item Apprentissage organisationnel
      \end{itemize}
  \end{itemize}
\end{frame}

\section{Technologies et architecture des KMS modernes}

\begin{frame}
  \frametitle{Panorama des bases de données}
  \begin{block}{Data Lake}
    \begin{itemize}
      \item Données brutes (structurées ou non)
      \item Risque de “data swamp” sans catégorisation (bronze $\to$ argent $\to$ gold)
      \item Outils : \texttt{Kafka}, \texttt{Spark}
    \end{itemize}
  \end{block}
  \begin{block}{Data Warehouse}
    \begin{itemize}
      \item Données strictement structurées
      \item Requêtes SQL, historique et reporting
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}
  \frametitle{Types de SGBD et cas d'usage}
  \begin{itemize}
    \item Relationnels (SQL) : table, ERD
    \item Wide-column : Cassandra, Redshift
    \item Document : MongoDB (JSON)
    \item Key-Value : Redis (cache)
    \item Time-series : Prometheus
  \end{itemize}
  \begin{block}{ACID (Relationnel)}
    Atomicité, Cohérence, Isolation, Durabilité
  \end{block}
\end{frame}

\begin{frame}
  \frametitle{Modélisation relationnelle -- Schéma ERD (TikZ)}
  \centering
  \begin{tikzpicture}[
    entity/.style={rectangle, draw=orange, fill=orange!20, minimum width=2.5cm, minimum height=1cm, align=center},
    attribute/.style={ellipse, draw=MediumPurple, fill=MediumPurple!20, minimum width=1.5cm, minimum height=0.8cm},
  ]
    % Entités
    \node[entity] (User) {Utilisateur};
    \node[entity] (Product) [right=6cm of User] {Produit};
    \node[entity] (Order) [below=3cm of $(User)!0.5!(Product)$] {Commande};

    % Attributs utilisateurs
    \node[attribute] (Uid) [above left=0.9cm and 0.5cm of User] {ID\_user};
    \node[attribute] (Uname) [above right=0.9cm and 0.5cm of User] {Nom};

    % Attributs produit
    \node[attribute] (Pid) [above right=0.9cm and 0.5cm of Product] {ID\_prod};
    \node[attribute] (Pname) [above left=0.9cm and 0.5cm of Product] {Libellé};

    % Attributs commande
    \node[attribute] (Oid) [below=1cm of Order] {ID\_comm};

    % Relations
    \draw (User) -- (Order) node[midway, left, sloped] {passe};
    \draw (Order) -- (Product) node[midway, right, sloped] {contient};

    % Liens entre attributs et entités
    \draw (Uid) -- (User);
    \draw (Uname) -- (User);
    \draw (Pid) -- (Product);
    \draw (Pname) -- (Product);
    \draw (Oid) -- (Order);
  \end{tikzpicture}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Exemple : requête SQL classique}
\begin{lstlisting}[language=SQL]
SELECT Produit.nom, COUNT(Commande.id)
FROM Commande
JOIN Produit ON Commande.produit_id = Produit.id
GROUP BY Produit.nom;
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Exemple équivalent en Pandas (Python)}
\begin{lstlisting}[language=Python]
df.groupby("Produit")["Commande"].count()
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Exemple équivalent en C\# (LINQ)}
\begin{lstlisting}[language={[Sharp]C}]
var result = commandes
   .GroupBy(c => c.Produit.Nom)
   .Select(g => new { Produit = g.Key, Nombre = g.Count() });
\end{lstlisting}
\end{frame}

\section{Limites du relationnel : cas des réseaux sociaux}

\begin{frame}
  \frametitle{Pourquoi SQL atteint ses limites ? (cas Facebook)}
  \begin{itemize}
    \item Recherche amis d’amis (multi-hop)
    \item Requêtes SQL très complexes à cause des multiples jointures
    \item Complexité élevée : $O(N^k)$ pour $k$ degrés d’amitié
    \item Modélisation et interrogation difficile de la structure réseau
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Exemple SQL : liste des amis d’amis (2 niveaux)}
\begin{lstlisting}[language=SQL]
SELECT f2.friend_id
FROM friends f1
JOIN friends f2 ON f1.friend_id = f2.user_id
WHERE f1.user_id = :me
\end{lstlisting}
\textbf{Note :} requête difficile à écrire et maintenir pour plus de 2 niveaux.
\end{frame}

\section{Graphe : solution adaptée aux réseaux complexes}

\begin{frame}
  \frametitle{Définition d’un graphe}
  \begin{itemize}
    \item Ensemble de nœuds (entités) : $V$
    \item Ensemble d’arêtes (relations) : $E$
    \item Exemple : Linked Property Graph (LPG) avec propriétés sur noeuds/arêtes
  \end{itemize}
  \centering
  \begin{tikzpicture}[node distance=2cm,auto,>=latex']
    \node[circle,draw] (A) {Moi};
    \node[circle,draw] (B) [right=of A, yshift=1cm] {Ami1};
    \node[circle,draw] (C) [right=of A, yshift=-1cm] {Ami2};
    \node[circle,draw] (D) [right=3cm of A] {Ami3};
    \draw[->] (A) to node[above] {ami} (B);
    \draw[->] (A) to node[below] {ami} (C);
    \draw[->] (B) to node[above] {ami} (D);
    \draw[->] (C) to node[below] {ami} (D);
  \end{tikzpicture}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Requête Cypher pour amis d’amis (Neo4j)}
\begin{lstlisting}
MATCH (me:User {name:"Moi"})-[:AMI*2]->(fof)
RETURN DISTINCT fof.name
\end{lstlisting}
\pause
\textit{[:AMI*2]} signifie : relations AMI parcourues 2 fois (amis des amis).
\end{frame}

\begin{frame}
  \frametitle{Comparaison RDF vs Property Graph}
  \begin{itemize}
    \item RDF : triplets (sujet, prédicat, objet) — orienté graphe sémantique
    \item Property Graph : nœuds et arêtes avec propriétés clé-valeur — orienté performance et flexibilité
  \end{itemize}
\begin{lstlisting}
SPARQL example :
SELECT ?fof WHERE {
  :Moi :ami/:ami ?fof
}
\end{lstlisting}
\end{frame}

\section{Recherche de similarité et parcours de graphes}

\begin{frame}
  \frametitle{Similarité sémantique par vectorisation}
  \begin{itemize}
    \item Embeddings vectoriels (Word2Vec, BERT, transformers)
    \item Calcul de similarité cosinus :
  \[
  \cos(\theta) = \frac{\vec{v}_1 \cdot \vec{v}_2}{\|\vec{v}_1\| \ \|\vec{v}_2\|}
  \]
  \item Applications : recommandation, détection de communautés, clustering
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Exemple Python : similarité de texte (embeddings)}
\begin{lstlisting}[language=Python]
from sklearn.metrics.pairwise import cosine_similarity
similarity = cosine_similarity([emb1], [emb2])
\end{lstlisting}
\end{frame}

\section{Architecture modulaire d’un KMS moderne}

\begin{frame}
  \frametitle{Architecture KMS}
  \begin{itemize}
    \item \textbf{Business logic} (règles métier)
    \item NLP (extraction, annotation d’entités)
    \item Graphes (centralité, parcours, clique)
    \item Vector DB (recherche par embeddings)
    \item Intégration dashboards / moteurs de recherche (OpenSearch)
    \item Plateformes intégrées (exemple : Curiosity avec C\#)
  \end{itemize}
\end{frame}

\section*{Conclusion}

\begin{frame}
  \frametitle{Conclusion}
  \begin{itemize}
    \item L’optimisation de la gestion des connaissances allie technologies, méthode et organisation
    \item Bases de données relationnelles restent utiles pour données structurées classiques
    \item Les graphes et NLP permettent de relier et exploiter la connaissance complexe à grande échelle
  \end{itemize}
\end{frame}

\end{document}

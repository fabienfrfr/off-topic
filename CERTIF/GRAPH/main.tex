\documentclass{beamer}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{xcolor}

\usetheme{Madrid}
\usecolortheme{seahorse}

\lstset{
  language=[Sharp]C,
  basicstyle=\ttfamily\small,
  keywordstyle=\color{blue}\bfseries,
  commentstyle=\color{gray}\itshape,
  stringstyle=\color{red},
  numbers=left,
  numberstyle=\tiny,
  stepnumber=1,
  numbersep=5pt,
  showstringspaces=false,
  breaklines=true,
  frame=single,
  backgroundcolor=\color{gray!10}
}


\begin{document}

\title{Knowledge Management \& Graphs Concepts}
\author{Fabien FURFARO}
\date{\today}
\frame{\titlepage}


\begin{frame}
  \frametitle{Sommaire}
  \tableofcontents
\end{frame}

\section{Présentation du contexte et du besoin}

\subsection{Historique}
\begin{frame}
  \frametitle{Historique}

  La gestion des connaissances (Knowledge Management) a évolué en plusieurs phases :
  \begin{itemize}
    \item Avant 1980 : pratiques informelles, catalogage manuel, échanges oraux.
    \item 1980-1995 : premiers outils informatiques et bases de connaissances structurées.
    \item 1995-2010 : plateformes collaboratives, moteurs de recherche spécialisés.
    \item 2010 et après : NLP/NLU, graph databases, transformers, accent sur gouvernance et modélisation.
  \end{itemize}
\end{frame}

\subsection{Défis actuels et objectifs}
\begin{frame}
  \frametitle{Défis actuels et objectifs}
  
  \begin{itemize}
  \item \textbf{Fragmentation} de l'information et silos de données.
  \item \textbf{Hétérogénéité} des systèmes.
  \item \textbf{Perte du savoir} par turnover ou absence de capitalisation.
  \end{itemize}
  
  Objectif : créer des plateformes « Google-like », capables de retrouver et structurer la connaissance avec un \textbf{KMS} (Knowledge Management System) s’appuyant sur curation humaine, ontologie métier, indexation croisée et technologies avancées (ex : knowledge graph, IA).
\end{frame}

\subsection{Composants d’un KMS moderne}
\begin{frame}
  \frametitle{Composants d’un KMS moderne}
  \begin{itemize}
    \item Modèles formels, ontologies.
    \item Moteurs de règle, systèmes experts.
    \item Knowledge graph, sémantique.
    \item IA (NLP/NLU, entity recognition, retrieval).
    \item Interfaces LLM/RAG, intégration outils métier.
  \end{itemize}
\end{frame}

\subsection{Cas d’usage : Curiosity}
\begin{frame}
  \frametitle{Cas d’usage : Curiosity}
  \begin{itemize}
    \item KMS basé sur un \textbf{Linked Property Graph (LPG)} développé en C\#.
    \item Détection automatique et pondération des entités (NLP).
    \item Recherche par similarité (subgraph embedding, vectorisation texte).
    \item Rapidité sur grands volumes (plusieurs centaines de milliers de docs).
  \end{itemize}
\end{frame}

\subsection{Bénéfices et limites}
\begin{frame}
  \frametitle{Bénéfices et limites}
  \begin{itemize}
    \item Gain de temps, pertinence, efficacité de support client
    \item Sécurité du patrimoine informationnel
    \item Défis persistants de désilotage, capitalisation experte, automatisation des process
  \end{itemize}
\end{frame}

\subsection{Exemple concret : aéronautique}
\begin{frame}
  \frametitle{Exemple concret : aéronautique}
  
  Déploiement progressif chez un avionneur : de 15 000 utilisateurs internes à plus de 100 000 clients externes, grâce à la puissance du knowledge graph pour résoudre des problématiques techniques complexes.
\end{frame}

\subsection{Approche Capgemini « Trust before technology »}
\begin{frame}
  \frametitle{Approche Capgemini « Trust before technology »}
  
  \begin{itemize}
    \item Diagnostic métier et technique approfondi, co-construction humaine + technologique, prototypage rapide permettant d’incarner la valeur ajoutée.
  \end{itemize}
\end{frame}

\section{Présentation des compétences nécessaires}

\subsection{Théorie et concepts fondamentaux}

\subsubsection{Graphes et connaissance}
\begin{frame}
  \frametitle{Graphes et connaissance}

  \begin{itemize}
    \item \textbf{Graphe orienté ou non orienté}: \( G = (V, E) \) avec \( V \) = nœuds (entités), \( E \) = arêtes (relations).
    \item \textbf{Linked Property Graph (LPG)}: chaque nœud/arête peut avoir des propriétés clé-valeur.
    \item \textbf{Requête sur graphe}: trouver des sous-graphes isomorphes, calcul de chemins, recherche de motifs.
  \end{itemize}
\end{frame}

\subsubsection{Sémantique, ontologies}
\begin{frame}
  \frametitle{Sémantique, ontologies}

  \begin{itemize}
    \item \textbf{Ontologie}: formalise les concepts et relations d’un domaine (ex : OWL, RDF Schema) ; utile pour donner du sens et permettre des inférences au-delà du simple graphe.
  \end{itemize}
\end{frame}

\subsubsection{Vectorisation et recherche sémantique}
\begin{frame}
  \frametitle{Vectorisation et recherche sémantique}

  \begin{itemize}
    \item \textbf{Embeddings}: vectorisation des nœuds/document associés pour calculer la similarité (cosinus, euclidienne) :
    \[
    \cos(\theta) = \frac{\mathbf{v}_1 \cdot \mathbf{v}_2}{\|\mathbf{v}_1\|\|\mathbf{v}_2\|}
    \]
    \item Techniques courantes : Word2Vec, GloVe, transformers (BERT/LLM).
  \end{itemize}
\end{frame}

\subsubsection{IA et NLP}
\begin{frame}
  \frametitle{IA et NLP}

  \begin{itemize}
    \item Extraction d’entités : reconnaissance automatique des entités dans un texte.
    \item Similarité sémantique : utiliser des modèles de langage pour relier de nouveaux cas à l’historique.
  \end{itemize}
\end{frame}

\subsection{Mathématiques et algorithmes de base}

\begin{frame}
  \frametitle{Algorithmes fondamentaux}
  \begin{itemize}
    \item Algorithme de parcours de graphe (DFS, BFS).
    \item Pagerank pour déterminer l’importance d’un nœud.
    \item Recherche de plus courts chemins (Dijkstra, A*).
    \item Recherche de sous-graphes similaires (isomorphisme de sous-graphe, graph embedding).
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Exemple d’algorithme : BFS en C\#}
\begin{lstlisting}
Queue<Node> queue = new Queue<Node>();
HashSet<Node> visited = new HashSet<Node>();
queue.Enqueue(startNode);

while (queue.Count > 0)
{
    Node current = queue.Dequeue();
    if (!visited.Contains(current))
    {
        visited.Add(current);
        foreach (Node neighbor in current.Neighbors)
        {
            queue.Enqueue(neighbor);
        }
    }
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Exemple de similarité cosinus entre deux embeddings}
\begin{lstlisting}
public double CosineSimilarity(double[] v1, double[] v2)
{
    double dot = 0.0, mag1 = 0.0, mag2 = 0.0;
    for (int i = 0; i < v1.Length; i++)
    {
        dot += v1[i] * v2[i];
        mag1 += v1[i] * v1[i];
        mag2 += v2[i] * v2[i];
    }
    return dot / (Math.Sqrt(mag1) * Math.Sqrt(mag2));
}
\end{lstlisting}
\end{frame}

\begin{frame}
  \frametitle{PageRank}
  Formule de base :
  \[
  PR(u) = \frac{1-d}{N} + d \sum_{v \in B_u} \frac{PR(v)}{L(v)}
  \]
  avec \( d \) = facteur d’amortissement (classiquement 0.85), \( N \) = nombre total de nœuds.
\end{frame}

\subsection{Exemple pratique de requête sur un LPG}

\begin{frame}[fragile]
  \frametitle{Définition d’un nœud et d’une relation en C\#}

\begin{lstlisting}
public class Node
{
    public string Id { get; set; }
    public Dictionary<string, object> Properties { get; set; }
}

public class Relationship
{
    public Node From { get; set; }
    public Node To { get; set; }
    public string Type { get; set; }
    public Dictionary<string, object> Properties { get; set; }
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Recherche des voisins d’un nœud (extraction de sous-graphe)}
\begin{lstlisting}
public List<Node> GetNeighbors(Node node, List<Relationship> relationships)
{
    return relationships
    .Where(r => r.From == node)
    .Select(r => r.To)
    .ToList();
}
\end{lstlisting}
\end{frame}


%%%

\section{Fondamentaux des Graphes et des Bases de Données Graphes}
\subsection{Introduction : Pourquoi les graphes ?}
\begin{frame}{Pourquoi les graphes ?}
  \begin{itemize}
    \item Représentation directe des entités et relations complexes (réseaux sociaux, routes, web, biologie).
    \item Résolution efficace des problématiques où les connexions comptent.
    \item Exemple : problème des sept ponts de Königsberg, modélisé par Euler (naissance de la théorie des graphes).
  \end{itemize}
\end{frame}

\subsection{Structures fondamentales d'un graphe}
\begin{frame}{Concepts de base}
  \begin{itemize}
    \item \textbf{Noeuds (sommets / vertices)}, \textbf{arêtes (edges)}, \textbf{propriétés}, \textbf{labels}
    \item Types : orienté / non orienté, pondéré / non pondéré, graphe cyclique / acyclique
    \item Modèles : adjacency list, adjacency matrix
  \end{itemize}
\end{frame}

\subsection{Comparaison SQL vs Bases de Données Graphes}
\begin{frame}{Relationnel vs Graphe}
  \begin{itemize}
    \item SQL : données en tables, relations via clés étrangères.
    \item Graphe : connexions directes entre entités, requêtes par traversée rapide.
    \item Avantages : absence d’index pour navigation, expressivité accrue pour les requêtes relationnelles complexes.
  \end{itemize}
  \begin{block}{Index-free Adjacency (Neo4j)}
    Les relations sont stockées sous forme de pointeurs, optimisant l’accès et la navigation dans le graphe.
  \end{block}
\end{frame}

\section{Modélisation et Requêtes dans une Base de Données Graphe (Neo4j)}
\subsection{Le Property Graph Model}
\begin{frame}{Le Property Graph Model}
  \begin{itemize}
    \item Noeuds et relations portent des propriétés clé-valeur.
    \item Typage par labels (noeuds) et types (relations).
  \end{itemize}
  \begin{block}{Exemple}
    \texttt{(:Person \{name: "Alex"\})-[:KNOWS]->(:Person \{name: "Jordan"\})}
  \end{block}
\end{frame}

\begin{frame}[fragile]{Cypher : Concepts clés}
  \begin{itemize}
    \item Syntaxe déclarative et visuelle inspirée de l’ASCII art.
    \item \texttt{MATCH}, \texttt{WHERE}, \texttt{RETURN}, \texttt{CREATE}, \texttt{MERGE}, \texttt{DELETE}
    \item Exemples :
      \begin{itemize}
        \item Requête basique :
\begin{lstlisting}
MATCH (n:Person)-[:KNOWS]->(friend)
WHERE n.name = "Alex"
RETURN friend.name
\end{lstlisting}
        \item Création :
\begin{lstlisting}
CREATE (a:Person {name:"Alice"})
\end{lstlisting}
      \end{itemize}
  \end{itemize}
\end{frame}

\subsection{Gremlin et autres langages de graphes}
\begin{frame}{Comparaison Cypher, Gremlin, GQL}
  \begin{itemize}
    \item \textbf{Cypher} : Déclaratif, standard Neo4j, pattern-matching, facile à apprendre.
    \item \textbf{Gremlin} : Orienté traversée (impératif), TinkerPop, multiplateforme, syntaxe en étapes (pipes).
    \item \textbf{GQL} (Graph Query Language) : Vers une normalisation ISO, synthèse de Cypher, PGQL et SQL/PGQ.
    \item \textbf{SPARQL} : Pour RDF, orienté graphe sémantique.
  \end{itemize}
\end{frame}

\section{Opérations, Indexation, Sécurité}
\begin{frame}{Transactions et Index}
  \begin{itemize}
    \item ACID, gestion des transactions.
    \item Indexation des nœuds et propriétés.
    \item Contrôle d’accès : RBAC (Role-Based Access Control).
    \item Sauvegarde, restauration, haute disponibilité.
  \end{itemize}
\end{frame}

\section{Requêtes Complexes et Algorithmes sur Graphes}
\subsection{Parallèle Relationnel / Graphe}
\begin{frame}{Jointures vs. Traversées de Graphe}
  \begin{itemize}
    \item Jointure relationnelle devient : traversée directe de relations.
    \item Avantage énorme sur les requêtes multi-hop ou à profondeur variable.
  \end{itemize}
\end{frame}

\subsection{La science des graphes appliquée}
\begin{frame}{Algorithmes et applications}
  \begin{itemize}
    \item \textbf{Recherche de chemin :}
      \begin{itemize}
        \item BFS, DFS, Dijkstra, A* (trouver le plus court chemin)
      \end{itemize}
    \item \textbf{Centralité et importance :}
      \begin{itemize}
        \item Degree, PageRank, Betweenness, Closeness
      \end{itemize}
    \item \textbf{Détection de communautés :}
      \begin{itemize}
        \item Louvain, Label Propagation 
      \end{itemize}
    \item \textbf{Similarité :}
      \begin{itemize}
        \item Cosine, Jaccard, node embedding (Word2Vec pour graphes)
      \end{itemize}
  \end{itemize}
\end{frame}

\subsection{Exemples d’algorithmes Cypher/Gremlin}
\begin{frame}[fragile]{Chemin le plus court Cypher}
\begin{lstlisting}
MATCH (start:Person {name: "Alice"}), (end:Person {name: "Bob"}),
path = shortestPath((start)-[*]-(end))
RETURN path
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Chemin le plus court Gremlin}
\begin{lstlisting}
g.V().has('name','Alice')
  .repeat(both().simplePath())
  .until(has('name','Bob'))
  .path()
  .limit(1)
\end{lstlisting}
\end{frame}

\begin{frame}{Community Detection / Embeddings}
  \begin{itemize}
    \item Community detection: séparation naturelle des sous-réseaux d’un graphe.
    \item Embeddings : vectorisation des nœuds pour le Machine Learning (proximité dans l’espace vectoriel encode la similarité structurelle).
    \item Applications : recommandation, analyse sociale, détection de fraudes.
  \end{itemize}
\end{frame}

\section{Import, Export et Outils d’Intégration}
\begin{frame}{Travail avec les données}
  \begin{itemize}
    \item Import : CSV, JSON, connecteurs (Kafka, Spark, etc.).
    \item Export : mêmes formats, intégration BI et ML.
    \item APIs : Driver Python, Java, REST, Bolt.
    \item Focus sur la conversion de graphes relationnels (\texttt{LOAD CSV}, mapping tables $\to$ nœuds et relations).
  \end{itemize}
\end{frame}

\section{Bonnes Pratiques et Certification}
\begin{frame}{Modélisation et bonnes pratiques}
  \begin{itemize}
    \item Limiter le nombre de labels par noeud (recommandé : $\leq$ 4)
    \item Favoriser les pattern simples et typés
    \item Utiliser index et contraintes pour l’unicité/sécurité
    \item Tester la performance des requêtes (\texttt{EXPLAIN}/\texttt{PROFILE}, analyse des plans d’exécution)
  \end{itemize}
\end{frame}

\begin{frame}{Certification Neo4j / Ressources}
  \begin{itemize}
    \item Certification officielle Neo4j Professional gratuite, accès en ligne.
    \item Sujets : Cypher, Modélisation, Sécurité, Algorithmes, Transactions.
    \item Plateformes de formation : Neo4j GraphAcademy, blog posts, documentation Neo4j.
    \item Pour aller plus loin : exploration de Gremlin (multi-db), comparaisons Cypher/Gremlin/SQL, utilisation de la GDS (Graph Data Science) Library pour l’IA.
  \end{itemize}
\end{frame}

\section*{Conclusion}
\begin{frame}{Conclusion}
\vspace{0.5cm}
\Large
Les graphes et bases de données orientées graphe sont au cœur des nouveaux challenges d’analyse et d’Intelligence Artificielle (exploiter les connexions, pas seulement les enregistrements).  
Cypher et Gremlin sont vos alliés pour explorer, analyser, et modéliser le réel numérique interconnecté.  
\bigskip

\footnotesize
Ressources complémentaires sur :\\
\url{https://graphacademy.neo4j.com/certifications/neo4j-certification/} \\
\url{https://data-xtractor.com/blog/category/graphs/} \\
\url{https://graphacademy.neo4j.com/courses/graph-data-science-fundamentals/}

\end{frame}

\end{document}
